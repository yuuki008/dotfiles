---
name: structured-workflow
description: リサーチ・計画・実装の3段階で複雑なタスクを構造的に進めるワークフロー。計画段階ではアノテーションサイクル（ユーザーがインラインコメント → Claude が反映を繰り返す）で品質を担保する。「/structured-workflow」「構造的に進めたい」「リサーチしてから計画を立てて」「しっかり調べてから実装して」「段階的に進めたい」で使用。コード開発、設計、ドキュメント作成、調査分析など、あらゆる複雑なタスクに対応。
---

# Structured Workflow

リサーチ → 計画 → 実装の3段階で複雑なタスクを進めるワークフロー。各段階でユーザーの承認を得てから次に進む。計画段階の**アノテーションサイクル**（ユーザーのインラインコメントを反復的に反映）が中核。

## 設計哲学

このワークフローは以下の原則に基づいている:

- **「実装は退屈であるべき」**: 創造的な意思決定はすべて計画段階で完了させる。実装は機械的な作業にする。これにより、Claude が初期段階で誤った仮説を立て、長時間かけて構築した結果をほどくという失敗パターンを排除する
- **ファイルベースの計画管理**: Claude Code のビルトインプラン機能ではなく、markdown ファイル（plan.md）を使う。理由は 3 つ: ①ユーザーがエディタで自由に編集できる、②完全な制御が可能、③プロジェクト内に永続化されコンテキスト圧縮後も参照できる
- **ユーザーが常に Driver's Seat にいる**: Claude に完全な自律性を与えない。ユーザーが意思決定権を持ち、Claude はそれに従う

## ワークフロー全体像

```
Stage 0: スコーピング → [ユーザー承認]
Stage 1: リサーチ   → research.md 作成 → [ユーザーレビュー・承認]
Stage 2: プランニング → plan.md 作成 → [アノテーションサイクル] → [ユーザー承認]
Stage 3: 実装       → plan.md の TODO 消化 → [ユーザーレビュー]
```

**ガードレール:** 各ステージのユーザー承認なしに次のステージへ進まない。特に「計画承認前の実装着手」は厳禁。

## 初回オファー

ユーザーに構造化ワークフローを提案する。

1. 4 つのステージを簡潔に説明する
2. タスクの複雑度に対してこのワークフローが適切か判断を仰ぐ
3. ユーザーが受け入れたら Stage 0 へ進む。辞退したらフリーフォームで対応する

## Stage 0: スコーピング

**目的:** タスクの範囲・制約・成功基準を明確にする。

### プロセス

1. ユーザーのタスク説明を聞く
2. 以下を明確化する質問を 3-5 問する:
   - 最終的なゴール・成果物は何か
   - 対象範囲（何を含み、何を含まないか）
   - 制約条件（技術的制約、時間、既存システムとの整合性）
   - 成功基準（何をもって完了とするか）
   - 優先順位（複数の要件がある場合）
3. ユーザーの回答をもとにスコープを 1 段落で要約する

### ゲート

スコープ要約をユーザーに提示し、合意を得る。合意が得られたら Stage 1 へ進む。

## Stage 1: リサーチ

**目的:** タスクに関連するドメイン・コードベース・コンテキストを深く調査し、research.md にまとめる。

**なぜリサーチが重要か:** Garbage in, garbage out。リサーチが間違えば計画も成果物も間違う。最大の失敗モードは個別のミスではなく、**既存の仕組み・慣例・文脈との不整合**である。例:
- コードタスク: 既存のキャッシング層を無視する関数、ORM の慣例を無視するマイグレーション、既存ユーティリティと重複するロジック
- ドキュメントタスク: 既存の用語集と矛盾する表現、他ドキュメントと重複する内容、読者の前提知識の誤認
- 設計タスク: 既存アーキテクチャとの不整合、運用制約の見落とし、チーム慣例の無視

### プロセス

1. スコープに基づき、調査すべき領域を特定してユーザーに共有する
2. 深い調査を実行する（タスクの種類に応じて対象を選択）:
   - **既存資産**: 関連するファイル・ドキュメント・成果物を徹底的に読み、依存関係・パターン・制約を把握する
   - **ドメイン**: 関連する概念・用語・ベストプラクティスを整理する
   - **先行事例**: 類似の実装・文書・設計パターンを探す
3. 調査プロセスをリアルタイムに報告する（何を見つけたか、何がまだ不明か）
4. 調査結果を作業ディレクトリの `research.md` に書き出す（作業ディレクトリについては「ファイル管理」セクション参照）

**「強い言葉」の重要性:** 調査指示には "deeply"、"in great details"、"intricacies" に相当する強い言葉を意識的に使う。「深く」「詳細に」「特殊ケースも含めて」「隅々まで」など。これらの言葉がないと表面的な読み込みに陥りやすい。例:
- ✅「このフォルダを**隅々まで**読み、内部の仕組みを**深く**理解して」
- ✅「通知システムを**詳細に**調査して」
- ✅「競合製品の価格体系を**網羅的に**調べて」
- ❌「このフォルダを読んで」「ざっと調べて」（表面的な調査になりがち）

### research.md の構成

```markdown
# リサーチ: [タスク名]

## 調査範囲
[何を調査したか]

## 調査結果
### [領域1]
[詳細な所見。表面的でなく、具体的な詳細・制約・特殊ケースを含める]

### [領域2]
...

## 重要な発見・注意点
[実装に影響する重要な制約、エッジケース、リスク]

## 未解決の疑問
[調査では解決できなかった点]
```

**品質基準:** 表面的な概要ではなく、次の計画段階での判断に必要な具体的詳細を含めること。research.md はユーザーが「Claude が本当に理解しているか」を検証するためのサーフェスでもある。誤解があればこの段階で修正できる。

### ゲート

research.md をユーザーに提示し、レビューを依頼する:

1. 調査結果に誤りや不足がないか確認を求める
2. 未解決の疑問について追加情報がないか尋ねる
3. ユーザーが調査完了と判断したら Stage 2 へ進む

## Stage 2: プランニング

**目的:** 詳細な計画を作成し、アノテーションサイクルで磨き上げる。

### プロセス

#### Step 1: 初期計画の作成

research.md をもとに作業ディレクトリの `plan.md` を作成する。

```markdown
# 計画: [タスク名]

## 概要
[何をどう実装するかの要約]

## 方針
[選択したアプローチとその理由。検討した代替案があれば簡潔に記載]

## 詳細設計
### [フェーズ/セクション 1]
[具体的な手順。タスクの種類に応じた詳細を含める]
[例: コード→スニペット・変更対象ファイル、ドキュメント→構成案・要点、設計→図・判断根拠]

### [フェーズ/セクション 2]
...

## 考慮事項
[トレードオフ、リスク、将来の拡張への影響]

## TODO
- [ ] [フェーズ1: タスク名]
  - [ ] [個別タスク1]
  - [ ] [個別タスク2]
- [ ] [フェーズ2: タスク名]
  - [ ] ...
```

**重要:** 計画には実行可能なレベルの具体性を持たせる。タスクの種類に応じて、コードスニペット、構成案、判断基準、具体例など、そのまま作業に着手できる粒度の情報を含める。

**参考資料の活用:** ユーザーが良い先行事例（オープンソースのコード、社内の既存成果物、他社の事例など）を知っている場合、それを参考資料として共有してもらう。参考資料があると計画の品質が大幅に向上する。ユーザーに「参考にしたい既存の事例はあるか」と積極的に尋ねること。例:
- コード: 「このライブラリの sortable ID の実装を参考に」
- ドキュメント: 「この API リファレンスの構成を参考に」
- 設計: 「この競合製品の UX フローを参考に」

#### Step 2: アノテーションサイクル

**これがこのワークフローの中核プロセス。**

1. plan.md をユーザーに提示し、レビューを依頼する
2. ユーザーに以下を説明する:
   - plan.md に直接インラインコメント（メモ・修正指示）を書き込んでよい
   - 短い指示で構わない（例: 「ここは不要」「この方式で」「トーンが硬い」「順序を入れ替え」）
   - 構造の変更、アプローチの却下、ドメイン知識の注入、何でも書き込める
3. ユーザーがコメントを追加したら:
   - 「plan.md にコメントを確認しました。すべてのコメントに対応して計画を更新します」と伝える
   - すべてのコメントに対応し、plan.md を更新する
   - **絶対に実装を開始しない**
   - 更新した plan.md をユーザーに再提示する
4. ユーザーが満足するまで 2-3 を繰り返す（通常 1-6 回）

**なぜアノテーションサイクルが効果的か:**
- plan.md が人間と AI の間の **shared mutable state**（共有可変状態）として機能する。チャットのスクロールを遡るより、構造化された仕様書上で議論するほうが遥かに効率的
- 通常 3 回程度のアノテーションで、汎用的な計画がそのシステムに適合した実装計画に変わる
- ユーザーは**プロダクトの優先順位**、**ユーザーの課題**、**エンジニアリング上のトレードオフ**など、Claude が自力では得られない知識を注入する。これがアノテーションの本質的な価値である

**アノテーションサイクル中のガードレール:**
- ユーザーのコメントをすべて漏れなく対応する
- 対応内容を箇条書きで報告する
- 「実装してよいか」とは聞かない。ユーザーから明示的な承認があるまで計画の修正を続ける

**ユーザーの介入レベル（Driver's Seat）:**

アノテーションサイクルでは、ユーザーは以下の 5 種類の介入ができる。すべてに従うこと:

1. **アイテムレベルの選別**: 提案された複数項目から個別に取捨選択する（例: 「1つ目は採用、4と5は不要」）
2. **スコープ削減**: 機能を計画から外す（例: 「ダウンロード機能は計画から外して」）
3. **インターフェース保護**: 既存の境界・構造の変更を禁止する（例: コード「この関数のシグネチャは変えるな」、ドキュメント「この章構成は維持して」）
4. **手法のオーバーライド**: 特定の技術・ツール・アプローチを指定する（例: コード「このライブラリを使え」、ドキュメント「です・ます調で統一」）
5. **焦点の修正**: 方向がずれた時にフォーカスを戻す（例: 「今は詳細ではなく全体構成に集中して」）

#### Step 3: TODO リストの最終化

アノテーションサイクル完了後、plan.md の TODO セクションが計画と整合しているか確認し、必要に応じて更新する。

### ゲート

ユーザーから計画の最終承認を得る。「この計画で実装を進めてよいか」と明示的に確認する。承認されたら Stage 3 へ進む。

## Stage 3: 実装

**目的:** 承認された計画に従って実装を実行する。創造的な意思決定は計画段階で完了しているため、ここでは機械的に計画を遂行する。

### 実行開始の定型指示

計画承認後、以下のような指示で実行を開始する:

> すべて実行して。タスク/フェーズが完了したら plan.md のチェックボックスをマークして。すべてのタスクが完了するまで止まらないで。

この定型指示には以下の意図が込められている:
- 「すべて実行して」= 計画の全項目を実行する（つまみ食いしない）
- 「チェックボックスをマーク」= plan.md が進捗の source of truth
- 「止まらない」= 中断なく一気通貫で実行

コードタスクの場合は以下も追加する:
> 不要なコメントは追加しない。型チェック・リント等を継続的に実行して。

### プロセス

1. plan.md の TODO リストに沿って実装を進める
2. 各タスク完了時に plan.md の該当 TODO にチェックを入れる (`- [x]`)
   - 子タスクをすべて完了したら、親（フェーズ）のチェックボックスも `- [x]` にする
3. 実行中の方針:
   - 計画にないことはやらない
   - 不要な装飾・補足を追加しない
   - 問題が発生したら、計画を逸脱する前にユーザーに報告する
   - コードタスクの場合: 型チェック・リント等を継続的に実行する。曖昧な型（any 等）を避け、具体的な型を使う
4. すべての TODO が完了するまで止まらずに続ける

### 実装中のフィードバック対応

計画が十分に練られているため、実装中のユーザー指示は短くて済む:

- ユーザーからの簡潔な修正指示に対応する（例: 「wider」「まだ切れてる」）
- **ビジュアルフィードバック**: ユーザーがスクリーンショットを添付した場合、テキスト説明より情報量が多いため積極的に活用する
- **既存パターンへの参照**: 「この部分は〇〇と同じ方式で」という指示に従う（全体を記述する必要がない）
- **リバートと再スコープ**: 方向性が根本的に間違っている場合は、無理に修正を重ねず、変更を戻してスコープを再設定する

### ゲート

全 TODO 完了後、ユーザーに最終レビューを依頼する:

1. plan.md の TODO がすべてチェック済みか確認する
2. 成果物をユーザーに提示する
3. 追加の修正が必要か確認する

## 運用ガイドライン

**トーン:**
- 各ステージで何をするか・なぜするかを簡潔に説明する
- 手続き的に進行し、過度な説明は避ける

**偏差への対応:**
- ユーザーがステージをスキップしたい場合: 理由を確認し、了承する
- リサーチが不要な場合（ユーザーが十分な知識を持つ場合）: Stage 1 をスキップ可
- 小さなタスクの場合: ワークフロー自体が過剰かもしれないことを伝える

**ファイル管理:**
- Stage 0 完了時に作業ディレクトリを作成する: `.claude/tmp/YYYYMMDD-{task-name}/`
  - `YYYYMMDD` は `date +%Y%m%d` で取得
  - `{task-name}` はスコーピングで決まったタスク名を kebab-case にしたもの（例: `20260215-doc-update-check`）
- research.md と plan.md はこの作業ディレクトリ内に作成する
- 過去のタスクの成果物は別ディレクトリに残るため、上書きの心配はない

**セッション管理:**
- 可能な限り、リサーチから実装まで1つのセッションで通す（コンテキスト維持のため）
- セッションを通じて Claude の理解が漸進的に深まる。フェーズ間でコンテキストを失わないことが品質に直結する
- plan.md はコンテキスト圧縮後も参照できる永続的なアーティファクトとして機能する
- コンテキストウィンドウの 50% 程度までは性能劣化が見られない。plan.md が永続的な参照点として機能するため、長いセッションでも方向性を維持できる

## 参考

- [How I Use Claude Code](https://boristane.com/blog/how-i-use-claude-code/) - Boris Tane
